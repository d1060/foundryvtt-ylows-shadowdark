import UtilitySD from "../utils/UtilitySD.mjs";
import BritannianMagicSD from "../sheets/magic/BritannianMagicSD.mjs";
import BritannianSpellSD from "../apps/BritannianSpellSD.mjs";
import AuraMagicSD from "../sheets/magic/AuraMagicSD.mjs";
import RollDialogSD from "./RollDialogSD.mjs";

export default class RollSD extends Roll {

	/**
	 * Main roll method for rolling. It checks if the roll is a
	 * d20, and if true, checks for special cases.
	 *
	 * The `data` object generally just needs an `actor` or and `item` as key:values.
	 *
	 * The `options` object configures the rolls, and chat messages. The following optional keys
	 * may be used:
	 * - fastForward {boolean}: Skips dialogs and just rolls normal rolls if set to true
	 * - rollMode {string}: If the self/gm/blind/public roll mode is to be predetermined
	 * - flavor {string}: Flavor text on the chat card (smaller text under actor name)
	 * - title {string}: Title of the chat card, set next to the icon
	 * - target {number}: If the roll has a target to meet or beat
	 * - dialogTemplate {handlebars}: Handlebars template to base Dialog on
	 * - dialogTitle {string}: The title of the rendered dialog
	 * - dialogOptions {object}: Options to be sent to the Dialog renderer
	 * - chatCardTemplate {handlebars}: Handlebars template to base Chatcard on
	 * - speaker {object}: Speaker as generated by `ChatMessage.getSpeaker()`
	 * - chatMessage {boolean}: Set to false if no chat message should be generated
	 *
	 * @param {Array<string>}		- Parts for the roll
	 * @param {object} data 		- Data that carries actor and/or item
	 * @param {jQuery} $form 		- Form from an evaluated dialog
	 * @param {number} adv			- Determine the direction of advantage (1)
	 * / disadvantage (-1)
	 * @param {object} options	- Options to modify behavior
	 * @returns {Promise<object>}
	 */
	static async Roll(parts, data, $form, adv=0, options={}) {
		if (!data.target && options.target) data.target = options.target;

		//shadowdark.debug(`RollSD Roll options.target=${options.target} data.rollType=${data.rollType} data.item?.type=${data.item?.type}`);
		// If the dice has been fastForwarded, there is no form
		if (!options.fastForward) {
			// Augment data with form bonuses & merge into data
			const formBonuses = this._getBonusesFromForm($form);
			//shadowdark.debug(`RollSD Roll merging data=${data} with formBonuses=${formBonuses}`);
			data.damage = this._getModifiedDamage($form, data.damage);
			data = foundry.utils.mergeObject(data, formBonuses);
		}

		if ($form)
			data.extraDamage = this._getExtraDamage($form);

		if (!options.rollMode) {
			// only override if it's actually been set on the form (some rolls
			// will have no form)
			options.rollMode = $form
				? this._getRollModeFromForm($form)
				: game.settings.get("core", "rollMode");
		}

		if (data.item && data.item.type === "Weapon" && !options.handedness) {
			// override with form input
			options.handedness = $form
				? this._getHandednessFromForm($form)
				: undefined;
		}

		if (!options.speaker && data.actor) options.speaker = ChatMessage.getSpeaker({actor: data.actor}),

		// Roll the Dice
		data.rolls = {
			main: await this._rollAdvantage(parts, data, adv),
		};
		
		if (data.resistedBy) await this.rollResistance(data, options);

		if (data.rollType === "ability") {
			data.actor?.onActionPerformed();
			return this._renderRoll(data, adv, options);
		}

		if (data.rollType === "hp") {
			return this._renderRoll(data, adv, options);
		}

		// Roll damage for NPCs attack types
		if (data.item?.type === "NPC Attack" || data.item?.type === "NPC Special Attack") {
			if (!options.flavor) {
				if (options.targetToken) {
					options.flavor = game.i18n.format(
						"SHADOWDARK.chat.item_roll.title_vs",
						{
							name: data.item.name,
							target: options.targetToken.actor.name,
						}
					);
				}
				else {
					options.flavor = game.i18n.format(
						"SHADOWDARK.chat.item_roll.title",
						{
							name: data.item.name,
						}
					);
				}
				if (data.hitLocation) {
					options.flavor += ' ' + game.i18n.format(
						"SHADOWDARK.roll.to_the",
						{
							location: data.hitLocation.name,
					});
				}
			}

			//data.extraFireDamage = data.actor.system.bonuses?.extraFireDamage ?? 0;
			//if (data.extraFireDamage) data.damageParts.push("@extraFireDamage");

			if (data.item.type === "NPC Attack") {
				data = await this._rollNpcAttack(data);
			}
			const result = await this._renderRoll(data, adv, options);
			await this._applyDamageToTargets(result, options, data);
			data.actor?.onActionPerformed();
			return result;
		}

		// Special cases for D20 rolls
		if (this._isD20or2d10(parts)) {
			// Weapon? -> Roll Damage dice
			if (data.item?.isWeapon()) {
				data.handedness = options.handedness;
				data.quickStrike = options.quickStrike;
				data.dualWeaponAttack = options.dualWeaponAttack;
				data.item.system.currentHand = data.handedness; // remember which hand used last
				data = await this._rollWeapon(data);
				if (!options.flavor) {
					if (options.targetToken) {
						options.flavor = game.i18n.format(
							"SHADOWDARK.chat.item_roll.title_vs",
							{
								name: data.item.name,
								target: options.targetToken.actor.name,
							}
						);
					}
					else {
						options.flavor = game.i18n.format(
							"SHADOWDARK.chat.item_roll.title",
							{
								name: data.item.name,
							}
						);
					}

					if (data.hitLocation) {
						options.flavor += ' ' + game.i18n.format(
							"SHADOWDARK.roll.to_the",
							{
								location: data.hitLocation.name,
						});
					}
				}
			}

			// Spell? -> Set a target
			if (data.item?.isSpell()) {
				// NPC spell
				if (typeof data.item.system.dc !== "undefined") {
					options.target = data.item.system.dc;
					options.tier = data.item.system.dc - 10;
					// system.tier needed for spell chat template
					data.item.system.tier = options.tier;
				}
				// player spell
				else {
					options.target = data.item.system.tier + data.baseDifficulty;
					options.tier = data.item.system.tier;
				}
				if (!options.flavor) {
					options.flavor = game.i18n.format(
						"SHADOWDARK.chat.spell_roll.title",
						{
							name: options.isFocusRoll ? game.i18n.localize("SHADOWDARK.chat.spell_focus_check") : data.item.name,
							tier: options.tier,
							spellDC: options.target,
						}
					);
				}
			}
		}

		if (data.auraMagic || data.abyssalMagic || data.mistMagic || data.nanoMagic || data.rollType.includes('-magic'))
		{
			var damage = data.damage;
			if (damage && (typeof damage === 'string' || damage instanceof String) && damage.includes("d"))
			{
				var spellDamageParts = [damage];
				data.rolls.damage = await this._roll(spellDamageParts, data);
			}
			else if (damage)
			{
				var fixedDamage = damage + "d1";
				var spellDamageParts = [fixedDamage];
				data.rolls.damage = await this._roll(spellDamageParts, data);
			}
		}

		// Check if it was a spell, and if it failed, lose it
		const result = await this._renderRoll(data, adv, options);

		if (
			data.item?.isSpell()
			&& result
			&& !result?.rolls?.main?.success?.value
			// Focus rolls shouldn't lose the spell, unless it is a critical
			&& (!options.isFocusRoll || result?.rolls?.main?.critical === "failure")
		) data.item.update({"system.lost": true});

		if (data.resistedBy) await this.renderResistanceRolls(data, options);

		// Reduce ammo if required
		if (data.usesAmmunition && data.ammunitionItem) {
			data.ammunitionItem.reduceAmmunition(1);
		}

		if (await data.item?.isExplosive())
			data.actor?.reduceQuantity(data.item, 1);

		await this._applyDamageToTargets(result, options, data);
		data.actor?.onActionPerformed();
		return result;
	}

	static async rollResistance(data, options) {
		if (!data.resistedBy) return;
		if (!(data.rolls?.main?.success?.value) && !(data.rolls?.main?.critical === "success")) return;

		if (data.resistedBy.toLowerCase() !== 'ac')
		{
			var tokens = [];
			if (options.targetToken)
				tokens.push(options.targetToken);
			if (data.targetTokens)
				tokens.push(...data.targetTokens);
			for (const target of game.user.targets.values())
			{
				if (!tokens.some(t => t.id === target.id))
					tokens.push(target);
			}
			
			if (tokens.length) data.wasAnyoneHit = false;
			data.resistanceRolls = [];
			for (let token of tokens) {
				if (token.actor)
				{
					let resistanceRoll = await this.rollOneResistance(token, data, data.rolls.main);
					if (!resistanceRoll.main.success) data.wasAnyoneHit = true;
					data.resistanceRolls.push(resistanceRoll);
				}
			}
		}
		else // if (data.resistedBy.toLowerCase() === 'ac')
		{
			var tokens = [];
			if (options.targetToken)
				tokens.push(options.targetToken);
			if (data.targetTokens)
				tokens.push(...data.targetTokens);
			for (const target of game.user.targets.values())
			{
				if (!tokens.some(t => t.id === target.id))
					tokens.push(target);
			}
			
			if (tokens.length) data.wasAnyoneHit = false;
			for (let token of tokens) {
				if (token.actor)
				{
					let [actorAc, acTooltip, isMetallic, metallicPart] = await token.actor.getArmorClass();
					if (options.power?.system?.talentClass === 'auraMagic') actorAc = await AuraMagicSD.getResistedAcBySpell(options.power, actorAc, isMetallic, metallicPart);
					if (options.power?.effect) actorAc = await BritannianSpellSD.getResistedAcBySpell(options.power, data.actor, actorAc, isMetallic);
					if (data.rolls?.main?.roll?._total < actorAc)
					{
						if (!data.acMisses) data.acMisses = [];
							data.acMisses.push(token.actor);
					}
					else
						data.wasAnyoneHit = true;
				}
			}
		}
	}

	static async rollOneResistance(token, data, mainRoll) {
		const resistanceAbility = data.resistedBy.toLowerCase();
		let target = data.resistanceDC ?? mainRoll.roll.total;
		let abilityBonus = token.actor.system.abilities[resistanceAbility].mod;
		let adv = 0;
		
		const resistanceData = {
			target,
			abilityBonus,
			actor: token.actor,
			tokenId: token.id,
		}
		resistanceData.rolls = {
			main: await this._rollAdvantage([(game.settings.get("shadowdark", "use2d10") ? "2d10" : "1d20"), '@abilityBonus'], resistanceData, adv),
			tokenId: token.id
		};
		return resistanceData.rolls;
	}

	static async renderResistanceRolls(data, options) {
		const resistanceAbility = data.resistedBy.toLowerCase();
		let target = data.resistanceDC ?? data.rolls.main.roll.total;

		for (let resistanceRoll of data.resistanceRolls ?? [])
		{
			let token = canvas.scene.tokens.find(t => t.id === resistanceRoll.tokenId);
			if (!token) continue;

			let abilityBonus = token.actor.system.abilities[resistanceAbility].mod;

			const resistanceData = {
				target,
				abilityBonus,
				actor: token.actor,
				rolls: resistanceRoll
			};
			delete resistanceData.rolls.main.roll['data'];

			const resistanceOptions = {
				target,
				title: game.i18n.format("SHADOWDARK.dialog.resistanceRoll", { name: token.actor.name, ability: data.resistedBy}),
				speaker: ChatMessage.getSpeaker({actor: token.actor})
			};

			await this._renderRoll(resistanceData, 0, resistanceOptions);
		}
	}
	
	static async _applyDamageToTargets(result, options, data) {
		if (game.settings.get("shadowdark", "enableTargetingDamage") && result?.rolls?.main?.success?.value && result.rolls.damage?.roll?._total)
		{
			var damageTotal = result.rolls.damage?.roll?._total;

			var tokens = [];
			if (options.targetToken)
				tokens.push(options.targetToken);
			else if (result.targetTokens)
				tokens = result.targetTokens;
			for (const target of game.user.targets.values())
			{
				if (!tokens.some(t => t.id === target.id))
					tokens.push(target);
			}

			for (var token of tokens)
			{
				var canApplyDamage = result.actor && (result.item || result.power || options.power) && token.actor;

				let resistanceRoll;
				if (result.resistanceRolls)
					resistanceRoll = result.resistanceRolls.find(r => r.main.roll.data?.actor?.id === token.actor?.id);
				if (resistanceRoll && resistanceRoll.main.success.value)
					continue;

				if (result.acMisses && result.acMisses.find(m => m.id === token.actor.id))
					continue;
				
				if (!data.isHealing)
				{
					if (data.extraFireDamage) damageTotal -= data.extraFireDamage;

					if (canApplyDamage)
						damageTotal = await this.checkDamageModifiers(result.item, result.power ?? options.power, result?.rolls?.main, token.actor, damageTotal);

					if (data.extraFireDamage) damageTotal = await this.addExtraDamageByType(data.extraFireDamage, 'fire', token.actor, damageTotal);
				}
				else
					damageTotal = -damageTotal;

				if (data.rolls.extraDamage && canApplyDamage)
				{
					for (let extraDamage of data.rolls.extraDamage)
					{
						damageTotal += await this.checkDamageModifiersByType(result.item, result?.rolls?.main, token.actor, extraDamage.roll.total, extraDamage.type);
					}
				}

				//shadowdark.debug(`Applying damage of ${damageTotal} to ${token.actor.name}`);

				if (damageTotal === 0)
					continue;

				if (!game.user.isGM) {
					if (token.actor.type == "NPC")
					{
						game.socket.emit(
							"system.shadowdark",
							{
								type: "changeNpcActorHP",
								data: {
									tokenId: token.id,
									damage: damageTotal,
									hitLocation: result.hitLocation,
								},
							}
						);
						token.refresh();
					}
				}
				else
				{
					await this.applyDamageToToken(token, damageTotal, result.hitLocation);
				}

				if (token.actor?.system?.bonuses?.automaticDamageOnCloseAttack && (options.attackType === 'melee' || options.attackType == null))
				{
					var actorToken = token.scene.tokens.find(t => t.actor?.id === data.actor.id);
					if (actorToken)
					{
						let automaticDamage = token.actor.system.bonuses.automaticDamageOnCloseAttack;
						if (token.actor?.system?.bonuses?.automaticDamageOnCloseAttackType) {
							automaticDamage = await this.checkDamageModifiersByType(null, null, actorToken.actor, automaticDamage, token.actor?.system?.bonuses?.automaticDamageOnCloseAttackType);
						}
						await this.applyDamageToToken(actorToken, automaticDamage);
					}
				}

				if (data.actor && token.actor?.system?.bonuses?.automaticPoisonOnCloseAttack && (options.attackType === 'melee' || options.attackType == null))
				{
					var rollParts = [game.settings.get("shadowdark", "use2d10") ? "2d10" : "1d20",
						data.actor.system.abilities['con'].mod.toString()];
					var rollResult = await this._roll(rollParts, {target: 15});

					if (rollResult.roll.total < 15)
					{
						if (!data.actor.system.bonuses?.poisonPenalty)
						{
							const effectData = [
								{
									name: "Poisoned",
									label: "Poisoned",
									img: "icons/magic/death/blood-corruption-vomit-red.webp",
									changes: [{	key: "system.bonuses.poisonPenalty", 
												mode: 2,
												value: token.actor?.system?.bonuses?.automaticPoisonOnCloseAttack}],
									disabled: false,
									origin: token.actor.uuid,
									transfer: true,
									description: "You were poisoned and now suffers from " + token.actor?.system?.bonuses?.automaticPoisonOnCloseAttack + " to all actions.",
									duration: { seconds: 3600 },
								},
							];

							await data.actor.createEmbeddedDocuments(
								"ActiveEffect",
								effectData
							);

							await this._renderRoll(
								{actor: data.actor,
								rolls: { main: rollResult } },
								0,
								{title: "Failed a Poison Resistance Check.",
								 chatCardTemplate: "systems/shadowdark/templates/chat/roll-card.hbs",
								 target: 15,
								 speaker: ChatMessage.getSpeaker({actor: data.actor}),
								});
						}
					}
					else
					{
						await this._renderRoll(
							{actor: data.actor,
							rolls: { main: rollResult, damage: damageResult } },
							0,
							{title: "Succeeded a Poison Resistance Check.",
							 chatCardTemplate: "systems/shadowdark/templates/chat/roll-card.hbs",
							 target: 15,
							 speaker: ChatMessage.getSpeaker({actor: data.actor}),
							});
					}
				}

				if (data.actor && token.actor?.system?.bonuses?.helvarion && (options.attackType === 'melee' || options.attackType == null) && (!token.actor?.system?.bonuses?.mistdarkCreature || token.actor.system.attributes.hp.value > 0))
				{
					await data.actor.makeTaintCheck();
				}
			}

			if (damageTotal != 0 && result.actor?.system?.bonuses?.regeneration)
			{
				var amountToRegenerate = result.actor?.system?.bonuses?.regeneration;
				result.actor.applyHealing(amountToRegenerate);
			}
		}
	}

	static async checkDamageModifiers(weapon, power, roll, target, damageTotal)
	{
		var attackDamageType = weapon?.system?.damage?.type;
		if (!attackDamageType && power && power.damage_type) attackDamageType = power.damage_type;
		if (!attackDamageType && power && power.system?.damage_type) attackDamageType = power.system.damage_type;
		if (!attackDamageType && power && power.effect?.damage_type) attackDamageType = power.effect.damage_type;
		if (!attackDamageType) attackDamageType = 'bludgeoning';

		return await this.checkDamageModifiersByType(weapon, roll, target, damageTotal, attackDamageType);
	}

	static async checkDamageModifiersByType(weapon, roll, target, damageTotal, attackDamageType)
	{
		if (target.system.bonuses?.immunity && !Array.isArray(target.system.bonuses.immunity)) target.system.bonuses.immunity = [target.system.bonuses.immunity];
		if (target.system.bonuses?.resistance && !Array.isArray(target.system.bonuses.resistance)) target.system.bonuses.resistance = [target.system.bonuses.resistance];

		if (target.system.bonuses?.platedBulwark && !(await weapon.isMagicItem()) && !(await weapon.isMagicDamage()) && target.isEquippingHeavyArmor)
			damageTotal -= parseInt(target.system.bonuses?.platedBulwark);

		if (target.system.bonuses?.livingMetalResistance &&
			(attackDamageType === 'bludgeoning' || attackDamageType === 'slashing' || attackDamageType === 'piercing'))
			damageTotal = Math.floor(damageTotal/2);
		else if (target.system.bonuses?.ancientSteelResistance &&
			(attackDamageType === 'bludgeoning' || attackDamageType === 'slashing' || attackDamageType === 'piercing') &&
			(weapon && !(await weapon.isExoticMaterial())))
			damageTotal = Math.floor(damageTotal/2);
		else if (target.system.bonuses?.crysteelResistance && (weapon && weapon.isMagicDamage()))
			damageTotal = Math.floor(damageTotal/2);
		else if (target.system.bonuses?.impervious && weapon && !(await weapon.isMagicItem()) && !(await weapon.isMagicDamage()))
			damageTotal = Math.floor(damageTotal/2);
		else if (target.system.bonuses?.antiGuardian && attackDamageType === 'electricity')
			damageTotal *= 2;
		else if (target.system.bonuses?.antiGuardian && weapon && !(await weapon.isMagicItem()) && !(await weapon.isMagicDamage()))
			damageTotal = Math.floor(damageTotal/2);
		else if (target.system.bonuses?.misty && (!roll?.critical || roll?.critical !== 'success') && attackDamageType !== 'fire' && attackDamageType !== 'cold' && attackDamageType !== 'electricity')
			damageTotal = 1;
		else if (target.system.bonuses?.incorporeal && weapon && !(await weapon.isMagicItem()) && !(await weapon.isMagicDamage()))
			damageTotal = 0;
		else if (target.system.bonuses?.immunity && (target.system.bonuses?.immunity ?? []).some(i => i.slugify() === attackDamageType.slugify()))
			damageTotal = 0;
		else if (target.system.bonuses?.resistance && (target.system.bonuses?.resistance ?? []).some(i => i.slugify() === attackDamageType.slugify()))
			damageTotal = Math.floor(damageTotal/2);
		else if (target.system.magic?.type === 'auraMagic' && attackDamageType === 'electricity')
			damageTotal = Math.floor(damageTotal/2);
		else if (target.system.bonuses?.helvarionWeakness && weapon && (await weapon.isCrysteel()))
			damageTotal += 3;
		else if (target.system.bonuses?.homogeneous && 
			(attackDamageType === 'bludgeoning' || attackDamageType === 'slashing' || attackDamageType === 'piercing') &&
			(weapon && !(await weapon.isExoticMaterial())))
			damageTotal = 1;
		
		return damageTotal;
	}

	static async addExtraDamageByType(extraDamage, damageType, target, damageTotal)
	{
		if (extraDamage === 0)
			return damageTotal;
		
		if (target.system.bonuses?.crysteelResistance)
			extraDamage = Math.floor(extraDamage/2);
		else if (target.system.bonuses?.antiGuardian && damageType === 'electricity')
			extraDamage = Math.floor(extraDamage/2);
		else if (target.system.bonuses?.immunity && (target.system.bonuses?.immunity ?? []).some(i => i.slugify() === damageType.slugify()))
			extraDamage = 0;
		else if (target.system.bonuses?.resistance && (target.system.bonuses?.resistance ?? []).some(i => i.slugify() === damageType.slugify()))
			extraDamage = Math.floor(extraDamage/2);
		damageTotal += extraDamage;
		return damageTotal;
	}

	static async applyDamageToToken(token, damage, hitLocation) {
		if (damage < 0)
			token.actor.applyHealing(-damage, 1);
		else
			token.actor.applyDamage(damage, 1);

		if (hitLocation != null)
			token.actor.applyHitLocationEffect(hitLocation);
		
		if (token.actor.type == "NPC" && token.actor.system.attributes.hp.value <= 0 && token.document && !token.document.hidden)
		{
			token.document.alpha = 0;

			const tokens = token.controlled ? canvas.tokens.controlled : [token];
			const updates = tokens.map(t => { return {_id: t.id, hidden: true};});
			await canvas.scene.updateEmbeddedDocuments("Token", updates);
			await token.actor.onDefeat();
		}

		if (token.actor.system.attributes.hp.value <= 0 && token.actor.system.summonedBy)
		{
			await BritannianMagicSD.deleteTokenAndActor(token.id);
			await BritannianMagicSD.removeActiveSpell(token.actor.system.summonedBy, token.actor.system.summonSpell);
		}
		if (token.actor.system.attributes.hp.value <= 0 && token.actor.system.shapeshiftedBy)
		{
			let casterToken = game.scenes.active.tokens.find(t => t.id === token.actor.system.shapeshiftedBy);
            await BritannianMagicSD.endShapeShift(casterToken, token);
			await BritannianMagicSD.deleteTokenAndActor(token.id);
			await BritannianMagicSD.removeActiveSpell(casterToken.actor.id, token.actor.system.shapeshiftSpell);
		}
	}

	/* -------------------------------------------- */
	/*  Roll Analysis                               */
	/* -------------------------------------------- */

	/**
	 * Checks if the roll is a D20 roll.
	 * @param {Array<string>} parts - Roll parts, starting with main dice
	 * @returns {boolean}
	 */
	static _isD20or2d10(parts) {
		if (typeof parts[0] !== "string") return false;
		if (!game.settings.get("shadowdark", "use2d10"))
		{
			if (parts[0] && parts[0].split("d"))
				return (parseInt(parts[0].split("d")[1], 10) === 20);
		}
		else
		{
			if (parts[0] && parts[0].split("d"))
			{
				if ((parseInt(parts[0].split("d")[0], 10) === 2 || parseInt(parts[0].split("d")[0], 10) === 3) &&
					parseInt(parts[0].split("d")[1], 10) === 10)
					return true;
				return false;
			}
		}
		return false;
	}

	/**
	 * Checks if a d20 has been rolled with either a result of
	 * 1 (failure) or 20 (success) and returns that as a string.
	 *
	 * Options:
	 * - critical.failureThreshold: Modified lower threshold for critical failure
	 * - critical.successThreshold: Modified higher threshold for critical success
	 *
	 * @param {Roll} roll 			- Roll results
	 * @param {object} options	- Options for the critical check
	 * @returns {string|null} 	- Analysis result
	 */
	static _digestCritical(roll, options={}) {
		if (roll.terms[0].faces !== ( game.settings.get("shadowdark", "use2d10") ? 10 : 20 ) )
			return null;

		// Check if different threshold are given as options
		var failureThreshold = (options.critical?.failureThreshold)
			? options.critical.failureThreshold : 1;
		if (game.settings.get("shadowdark", "use2d10")) failureThreshold++;

		var successThreshold = (options.critical?.successThreshold)
			? options.critical.successThreshold : 20;

		if (options.increasedCriticalRange)
			successThreshold -= options.increasedCriticalRange;

		// Get the final result if using adv/disadv
		if ( roll.terms[0].total >= successThreshold )
			return "success";
		else if ( roll.terms[0].total <= failureThreshold )
			return "failure";
		return null;
	}

	/**
	 * Removes the `@bonus` valeus from `parts` array that do not have
	 * corresponding `data.bonus` value, for a cleaner roll.
	 * @param {Array<string>} parts - Parts with bonuses to add to roll, starting with at
	 * @param {object} data 				- Data object containing `data.bonusX` values
	 * @returns {Array<string>}			- Parts with only defined bonuses in data object
	 */
	static _digestParts(parts, data) {
		const reducedParts = [];

		for (let part of parts)
		{
			if (data[part.substring(1)] && parseInt(data[part.substring(1)], 10) !== 0)
				reducedParts.push(part);
			if (/^\d+$/.test(part))
				reducedParts.push(part);
		}

		return reducedParts;
	}

	/**
	 * Modifies the first term in `rollParts` to roll with either advantage
	 * or disadvantage. Does nothing if multiple dice are first parts.
	 * @param {Array<string>} rollParts	- Array containing parts for rolling
	 * @param {-1|0|1} adv 							- Pre-determined Advantage
	 * @returns {Array<string>}					- Modified rollParts
	 */
	static _partsAdvantage(rollParts,	adv=0) {
		const splitDice = rollParts[0].split("d");
		if (game.settings.get("shadowdark", "use2d10"))
		{
			if (splitDice[0] === "") splitDice[0] = 1;

			if (parseInt(splitDice[0], 10) !== 1 && parseInt(splitDice[1], 10) !== 10)
			{
				return rollParts;
			}

			if (adv === 1) {
				rollParts[0] = `${parseInt(splitDice[0], 10) + 1}d${splitDice[1]}kh${splitDice[0]}`;
			}
			else if (adv === -1) {
				rollParts[0] = `${parseInt(splitDice[0], 10) + 1}d${splitDice[1]}kl${splitDice[0]}`;
			}
		}
		else
		{
			if (splitDice[0] === "") splitDice[0] = 1;

			if (parseInt(splitDice[0], 10) !== 1) return rollParts;

			if (adv === 1) {
				rollParts[0] = `${splitDice[0] * 2}d${splitDice[1]}kh`;
			}
			else if (adv === -1) {
				rollParts[0] = `${splitDice[0] * 2}d${splitDice[1]}kl`;
			}
		}
		return rollParts;
	}

	/* -------------------------------------------- */
	/*  Dice Rolling                                */
	/* -------------------------------------------- */

	/**
	 * Rolls dice, with parts. Evaluates them, and returns the data.
	 * @param {Array<string>}	parts	- Dice and Bonuses associated with the roll `@bonus`
	 * @param {object} data					- Data for the roll, incl. values for bonuses, like
	 * `data.bonus`
	 * @returns {object} 						- Returns the evaluated `roll`, the rendered
	 * HTML `renderedHTML`, and `critical` info.
	 */
	static async _roll(parts, data={}) {
		// Check the numDice has been given, otherwise add 1 dice
		if (parts[0][0] === "d") parts[0] = `1${parts[0]}`;

		// Save the first entry, assuming this is the main dice
		const mainDice = parts[0];
		const secondaryDice = [];
		for (let i = 1; i < parts.length; i++)
		{
			if (parts[i].startsWith('@'))
				continue;
			if (parts[i].includes('d'))
				secondaryDice.push(parts[i]);
		}

		parts = this._digestParts(parts, data);

		// Put back the main dice
		if (secondaryDice.length > 0)
		{
			for (let i = secondaryDice.length - 1; i >= 0; i--)
				parts.unshift(secondaryDice[i]);
		}
		parts.unshift(mainDice);

		var roll = await new Roll(parts.join(" + "), data).evaluate({maximize: (data.maxDamage ? true : false)});
		if (data.extraFireDamage)
		{
			var fireDamageFormulaPart = "+ " + data.extraFireDamage;
			roll._formula = this._wrapModifier(roll._formula, fireDamageFormulaPart, '<span style="font-weight: bold; color: #bb0000;">', '</span>');
		}
		let renderOptions = {
			template: 'systems/shadowdark/templates/dice/roll.hbs'
		};
		if (data.type) {
			renderOptions.flavor = data.type;
		} 
		const renderedHTML = await roll.render(renderOptions);

		// Also send the actors critical bonuses in case it has modified thresholds
		const critical = this._digestCritical(roll, data.actor?.system?.bonuses);

		const result = {
			roll,
			renderedHTML,
			critical,
		};
		if (data.target !== null) result.success = {value: result.roll.total >= data.target};

		return result;
	}

	static _wrapModifier(expression, partToWrap, insertStart, insertEnd) {
		// Match the dice expression (like 1d6 or 2d10) and following modifiers
		var index = expression.indexOf(partToWrap);
		if (index === -1)
			return expression;

		expression = expression.slice(0, index) + insertStart + expression.slice(index);
		index = expression.indexOf(partToWrap);
		expression = expression.slice(0, index + partToWrap.length) + insertEnd + expression.slice(index + partToWrap.length);
		return expression;
	}

	/**
	 * Modifies the first dice to roll it with advantage (2dXkh) or
	 * disadvantage (2dXkl).
 	 * @param {Array<string>} parts - Main Dice, and bonus parts (`@bonus`)
	 * @param {object} data 				- Data carrying object for use in roll.
	 * @param {-1|0|1} adv 					- Determine the direction of advantage (1)
	 * / disadvantage (-1) or normal (0).
	 * @returns {object}						- Object containing evaluated roll data
	 */
	static async _rollAdvantage(parts, data={}, adv=0) {
		//shadowdark.debug(`_rollAdvantage entrance: ${parts.join(" ")}`);
		parts = this._partsAdvantage(parts, adv);
		//shadowdark.debug(`_rollAdvantage final: ${parts.join(" ")}`);
		return this._roll(parts, data);
	}

	/**
	 * Analyses provided `data` and rolls with supplied bonuses, and advantage if
	 * requested.
	 * @param {Array<string>} parts - Bonus parts (@bonus) for consideration in roll
	 * @param {object} data 				- Data carrying object for use in roll.
	 * @param {-1|0|1} adv 					- Determine the direction of advantage (1)
	 * 																/ disadvantage (-1)
	 * @returns {object}						- Object containing evaluated roll data
	 */
	static async _rollD20(parts = [], data={}, adv=0) {
		// Modify the d20 to take advantage in consideration
		if ( parts[0] !== game.settings.get("shadowdark", "use2d10") ? "2d10" : "1d20") parts.unshift(game.settings.get("shadowdark", "use2d10") ? "2d10" : "1d20");
		return this._rollAdvantage(parts, data, adv);
	}

	/* -------------------------------------------- */
	/*  Special Case Rolling                        */
	/* -------------------------------------------- */

	/**
	 * Rolls an NPC attack.
	 * @param {object} data - Object containing the item document of rolled item
	 * @returns {object}		- Returns the data object, with additional roll evaluations
	 */
	static async _rollNpcAttack(data) {
		let baseDamageFormula = data.damage ?? data.item.system.damage.value ?? "";
		baseDamageFormula = baseDamageFormula.trim();

		// Default to 1 damage if no damage formula has been set
		baseDamageFormula = baseDamageFormula === "" ? "1" : baseDamageFormula;

		// Get bonus damage
		data.damageBonus = data.item.system.bonuses?.damageBonus;
		if (data.damageBonus) data.damageParts.push("@damageBonus");

		if (data.rolls?.main?.critical !== "failure") {
			if (data.rolls?.main?.critical === "success") {
				// We only support multiplication of the first damage dice,
				// which is probably enough. None of the core game NPC attacks
				// involve multiple dice parts
				//
				if (baseDamageFormula !== "0") {
					const parts = /^(\d*)d(.*)/.exec(baseDamageFormula);

					let numDice = "1";
					let formulaSuffix = "";
					if (parts) {
						numDice = parts[1] !== "" ? parts[1] : "1";
						formulaSuffix = parts[2] ? parts[2] : "";
					}

					numDice = parseInt(numDice, 10);
					numDice *= parseInt(data.item.system.bonuses?.critical.multiplier, 10);

					baseDamageFormula = formulaSuffix !== ""
						? `${numDice}d${formulaSuffix}`
						: `${numDice}`;
				}
			}

			const damageParts = [baseDamageFormula, ...data.damageParts];

			if (data.hitLocation != null && data.hitLocation.effect != null && data.hitLocation.effect == 'maxDamage')
				data.maxDamage = true;

			if (!data.rolls) data.rolls = { damage : {} };
			if (data.actor.system.bonuses?.savageStrike)
			{
				var damageRoll1 = await this._roll(damageParts, data);
				var damageRoll2 = await this._roll(damageParts, data);
				if (damageRoll1.roll.total > damageRoll2.roll.total)
				{
					data.rolls.damage = damageRoll1;
					data.rolls.damage2 = damageRoll2;
				}
				else
				{
					data.rolls.damage = damageRoll2;
					data.rolls.damage2 = damageRoll1;
				}
			}
			else
				data.rolls.damage = await this._roll(damageParts, data);
		}

		return data;
	}

	/**
	 * Rolls a weapon when suppled in the `data` object.
	 * @param {object} data - Object containing the item document of rolled item
	 * @returns {object} - Returns the data object, with additional roll evaluations
	 */
	static async _rollWeapon(data) {

		if (data.item?.system?.damage?.type) data.type = data.item.system.damage.type;
		// Get dice information from the weapon
		let baseDamageFormula = data.damage ?? data.item.system.damage.value ?? "";
		let dualBonus = null;
		if (baseDamageFormula.includes('+'))
		{
			let baseDamageFormulaParts = baseDamageFormula.split('+');
			baseDamageFormula = baseDamageFormulaParts[0];
			baseDamageFormulaParts.splice(0, 1);
			dualBonus = baseDamageFormulaParts.join('+');
		}
		let damageParts = baseDamageFormula.split("d");
		let numDice = parseInt(damageParts[0]);

		let damageDie1H = data.item.system.damage.oneHanded ?? false;
		let damageDieParts1H = damageDie1H.split('d');
		if (damageDieParts1H.length > 1)
			damageDie1H = 'd' + damageDieParts1H[1];

		let damageDie2H = data.item.system.damage.twoHanded ?? false;
		let damageDieParts2H = damageDie2H.split('d');
		if (damageDieParts2H.length > 1)
			damageDie2H = 'd' + damageDieParts2H[1];

		// Improve the base damage die if this weapon has the relevant property
		const weaponDamageDieImprovementByProperty =
			data.actor.system.bonuses?.weaponDamageDieImprovementByProperty ?? [];

		for (const property of weaponDamageDieImprovementByProperty) {
			if (await data.item.hasProperty(property)) {
				if (damageDie1H) {
					damageDie1H = shadowdark.utils.getNextDieInList(
						damageDie1H,
						shadowdark.config.DAMAGE_DICE
					);
				}

				if (damageDie2H) {
					damageDie2H = shadowdark.utils.getNextDieInList(
						damageDie2H,
						shadowdark.config.DAMAGE_DICE
					);
				}
			}
		}

		if (data.actor.system.bonuses?.overdraw)
		{
			for (const overdrawWeapon of data.actor.system.bonuses?.overdraw)
			{
				if (overdrawWeapon == data.item.name.slugify())
				{
					if (damageDie1H) {
						damageDie1H = shadowdark.utils.getNextDieInList(
							damageDie1H,
							shadowdark.config.DAMAGE_DICE
						);
					}

					if (damageDie2H) {
						damageDie2H = shadowdark.utils.getNextDieInList(
							damageDie2H,
							shadowdark.config.DAMAGE_DICE
						);
					}
				}
			}
		}

		if (data.actor.system.bonuses?.unarmedStrike && await data.item.hasProperty("unarmed"))
		{
			if (damageDie1H) {
				damageDie1H = shadowdark.utils.getNextDieInList(
					damageDie1H,
					shadowdark.config.DAMAGE_DICE
				);
			}

			if (damageDie2H) {
				damageDie2H = shadowdark.utils.getNextDieInList(
					damageDie2H,
					shadowdark.config.DAMAGE_DICE
				);
			}
			
			if (data.actor.level >= 3)
			{
				if (damageDie1H) {
					damageDie1H = shadowdark.utils.getNextDieInList(
						damageDie1H,
						shadowdark.config.DAMAGE_DICE
					);
				}

				if (damageDie2H) {
					damageDie2H = shadowdark.utils.getNextDieInList(
						damageDie2H,
						shadowdark.config.DAMAGE_DICE
					);
				}
			}
			
			if (data.actor.level >= 9)
			{
				if (damageDie1H) {
					damageDie1H = shadowdark.utils.getNextDieInList(
						damageDie1H,
						shadowdark.config.DAMAGE_DICE
					);
				}

				if (damageDie2H) {
					damageDie2H = shadowdark.utils.getNextDieInList(
						damageDie2H,
						shadowdark.config.DAMAGE_DICE
					);
				}
			}
		}

		if (data.actor.system.bonuses?.devastatingBlows && await data.item.hasProperty("unarmed"))
		{
			for (let i = 0; i < data.actor.system.bonuses?.devastatingBlows; i++)
			{
				if (damageDie1H) {
					damageDie1H = shadowdark.utils.getNextDieInList(
						damageDie1H,
						shadowdark.config.DAMAGE_DICE
					);
				}

				if (damageDie2H) {
					damageDie2H = shadowdark.utils.getNextDieInList(
						damageDie2H,
						shadowdark.config.DAMAGE_DICE
					);
				}
			}
		}

		// Check if damage die is modified by talent
		if (data.actor.system.bonuses?.weaponDamageDieD12.some(
			t => [data.item.name.slugify(), data.item.system.baseWeapon.slugify()].includes(t)
		)) {
			if (damageDie1H) damageDie1H = "d12";
			if (damageDie2H) damageDie2H = "d12";
		}

		// Check and handle critical failure/success
		if ( data.rolls.main.critical !== "failure" ) {
			// Adds dice if backstabbing
			if (data.backstab) {
				// Additional dice

				numDice += 1 + Math.floor(data.actor.level / 2);

				if (data.actor.system.bonuses?.backstabDie) {
					numDice +=
						parseInt(data.actor.system.bonuses?.backstabDie, 10);
				}
			}

			// Multiply the dice with the items critical multiplier
			if ( data.rolls.main.critical === "success") {
				numDice
					*= parseInt(data.item.system.bonuses?.critical.multiplier, 10);

				if (data.actor.system.bonuses?.perfectStrike)
					data.maxDamage = true;
			}

			// Check if a damage multiplier is active for either Weapon or Actor
			const damageMultiplier = Math.max(
				parseInt(data.item.system.bonuses?.damageMultiplier ?? 0, 10),
				parseInt(data.actor.system.bonuses?.damageMultiplier ?? 0, 10),
				1
			);

			let oneHandedParts;
			let twoHandedParts;
			let dualWieldParts;
			
			if (damageDie1H) {
				const damageRoll1H = (damageMultiplier > 1)
					? `${numDice}${damageDie1H} * ${damageMultiplier}`
					: `${numDice}${damageDie1H}`;

				oneHandedParts = [damageRoll1H, ...data.damageParts];
			}

			if (damageDie2H) {
				const damageRoll2H = (damageMultiplier > 1)
					? `${numDice}${damageDie2H} * ${damageMultiplier}`
					: `${numDice}${damageDie2H}`;

				twoHandedParts = [damageRoll2H, ...data.damageParts];
			}
			
			if (data.dualWeaponAttack) {
				dualWieldParts = [oneHandedParts[0], dualBonus, ...data.damageParts];
				data.handedness = "dw";
			}
			else if (dualBonus != null)
			{
				oneHandedParts?.push(dualBonus);
				twoHandedParts?.push(dualBonus);
			}

			if ((data.actor.system.bonuses?.weaponDamageAdvantage && data.actor.system.bonuses?.weaponDamageAdvantage == data.item.name.slugify()) ||
				(data.actor.system.bonuses?.savageStrike))
			{
				var damageRoll1 = await this._rollDamage(data, dualWieldParts, oneHandedParts, twoHandedParts, damageDie1H, damageDie2H);
				var damageRoll2 = await this._rollDamage(data, dualWieldParts, oneHandedParts, twoHandedParts, damageDie1H, damageDie2H);
				if (damageRoll1.roll.total > damageRoll2.roll.total)
				{
					data.rolls.damage = damageRoll1;
					data.rolls.damage2 = damageRoll2;
				}
				else
				{
					data.rolls.damage = damageRoll2;
					data.rolls.damage2 = damageRoll1;
				}
			}
			else
				data.rolls.damage = await this._rollDamage(data, dualWieldParts, oneHandedParts, twoHandedParts, damageDie1H, damageDie2H);
		}

		if (data.extraDamage?.length) {
			data.rolls.extraDamage = [];
			for (let extraDamage of data.extraDamage) {
				let extraDamageRoll = await this._rollDamage({actor: data.actor, handedness: '1h', type: extraDamage.type}, null, [extraDamage.damage], null, null, null);
				extraDamageRoll.type = extraDamage.type;
				data.rolls.extraDamage.push(extraDamageRoll);
			}
		}

		return data;
	}
	
	static async _rollDamage(data, dualWieldParts, oneHandedParts, twoHandedParts, damageDie1H, damageDie2H) {
		if (data.hitLocation != null && data.hitLocation.effect != null && data.hitLocation.effect == 'maxDamage')
			data.maxDamage = true;

		var damageRoll;
		// if (data.actor.system.bonuses?.weaponDamageAdvantage && data.actor.system.bonuses?.weaponDamageAdvantage == data.item.name.slugify())
		// {
		// 	switch (data.handedness) {
		// 		case "dw":
		// 			damageRoll = await this._rollAdvantage(dualWieldParts, data, 1);
		// 			break;
		// 		case "1h":
		// 			damageRoll = await this._rollAdvantage(oneHandedParts, data, 1);
		// 			break;
		// 		case "2h":
		// 			damageRoll = await this._rollAdvantage(twoHandedParts, data, 1);
		// 			break;
		// 		case undefined:
		// 			if (damageDie1H && damageDie2H) {
		// 				damageRoll = await this._rollAdvantage(oneHandedParts, data, 1);
		// 				data.rolls.secondaryDamage = await this._rollAdvantage(twoHandedParts, data, 1);
		// 			}
		// 			else {
		// 				damageRoll = await this._rollAdvantage(oneHandedParts ?? twoHandedParts, 1);
		// 			}
		// 	}
		// }

		switch (data.handedness) {
			case "dw":
				damageRoll = await this._roll(dualWieldParts, data);
				break;
			case "1h":
				damageRoll = await this._roll(oneHandedParts, data);
				break;
			case "2h":
				damageRoll = await this._roll(twoHandedParts, data);
				break;
			case undefined:
				if (damageDie1H && damageDie2H) {
					damageRoll = await this._roll(oneHandedParts, data);
					data.rolls.secondaryDamage = await this._roll(twoHandedParts, data);
				}
				else {
					damageRoll = await this._roll(oneHandedParts ?? twoHandedParts);
				}
		}
		return damageRoll;
	}

	/* -------------------------------------------- */
	/*  Dialog & Form Digestion                     */
	/* -------------------------------------------- */

	/**
	 * Extract the roll mode from a form
	 * @param {jQuery} $form 	- Callback HTML from dialog
	 * @returns {string}			- Selected Rollmode
	 */
	static _getRollModeFromForm($form) {
		let rollModeValue;
		if (typeof $form?.find === "function") {
			// It's a jQuery object
			rollModeValue = $form.find('[name="rollMode"]').val();
		} else {
			// Assume it's a DOM element
			const input = $form.querySelector('[name="rollMode"]');
			rollModeValue = input?.value;
		}
		return rollModeValue;
	}

	/**
	 * Parses a submitted dialog form for bonuses
	 * @param {jQuery} $form 	- Submitted dialog form
	 * @returns {object}			- Bonuses from the dialog form
	 */
	static _getBonusesFromForm($form) {
		const bonuses = {};
		if (typeof $form?.find === "function") {
			if ($form.find("[name=item-bonus]").length) bonuses.itemBonus = $form.find("[name=item-bonus]")?.val();
			if ($form.find("[name=ability-bonus]").length) bonuses.abilityBonus = $form.find("[name=ability-bonus]")?.val();
			if ($form.find("[name=talent-bonus]").length) bonuses.talentBonus = $form.find("[name=talent-bonus]")?.val();
			if ($form.find("[name=weapon-backstab]").length) bonuses.backstab = $form.find("[name=weapon-backstab]")?.prop("checked");
			if ($form.find("[name=target-lock]").length) bonuses.targetLock = $form.find("[name=target-lock]")?.prop("checked") ? 2 : null;
		} else {
			var input = $form.querySelector('[name="item-bonus"]');
			if (input) { bonuses.itemBonus = input.value; }

			input = $form.querySelector('[name="ability-bonus"]');
			if (input) { bonuses.abilityBonus = input.value; }

			input = $form.querySelector('[name="talent-bonus"]');
			if (input) { bonuses.talentBonus = input.value; }

			input = $form.querySelector('[name="weapon-backstab"]');
			if (input) { bonuses.backstab = input.checked; }

			input = $form.querySelector('[name="target-lock"]');
			if (input) { bonuses.targetLock = input.checked ? 2 : null; }
		}
		return bonuses;
	}

	static _getModifiedDamage($form, prevDamage) {
		if (typeof $form?.find === "function") {
			if ($form.find("[name=damage]").length) return $form.find("[name=damage]")?.val();
			else if ($form.find("[name='data.damage']").length) return $form.find("[name=damage]")?.val();
		} else {
			var input = $form.querySelector('[name="damage"]');
			if (input) { return input.value; }
			var input = $form.querySelector('[name="data.damage"]');
			if (input) { return input.value; }
		}
		return prevDamage;
	}

	static _getExtraDamage($form) {
		let extraDamage = [];
		var inputs = $form.querySelectorAll('[name^="extraDamage_"]');
		inputs.forEach(input => {
  			extraDamage.push({
				damage: input.value,
				type: input.dataset.type
			});
		});
		return extraDamage;
	}

	/**
	 * Parses a submitted dialog form for weapon handedness
	 * @param {jQuery} $form 	- Submitted dialog form
	 * @returns {string}		- Handedness from the dialog form
	 */
	static _getHandednessFromForm($form) {
		let radios;
		if (typeof $form?.find === "function") {
			// It's a jQuery object
			radios = $form.find("[name=weapon-handedness]");
		} else {
			// Assume it's a DOM element
			radios = $form.querySelector('[name="weapon-handedness"]');
		}

		if (radios[0]?.checked) return "1h";
		if (radios[1]?.checked) return "2h";""
	}

	/* -------------------------------------------- */
	/*  Dialogs                                     */
	/* -------------------------------------------- */

	/**
	 * Renders HTML for display as roll dialog
	 * @param {Array<string>} parts		- Dice formula parts
	 * @param {object} data 					- Data for use in the dialog
	 * @param {object} options 				- Configuration options for dialog
	 * @returns {jQuery}							- Rendered HTML object
	 */
	static async _getRollDialogContent(
		parts,
		data,
		options = {}
	) {
		const dialogTemplate = options.dialogTemplate
			? options.dialogTemplate
			: "systems/shadowdark/templates/dialog/roll-dialog.hbs";

		if (data.item?.system?.damage != null && data.damage == null)
			data.itemDamage = data.item?.system?.damage;
		if (data.item?.system?.extraDamage != null && data.extraDamage == null)
			data.itemExtraDamage = data.item?.system?.extraDamage;

		const dialogData = {
			data,
			title: options.title,
			formula: Array.from(parts).join(" + "),
			rollModes: CONFIG.Dice.rollModes,
			rollMode: options.rollMode,
			target: options.target,
		};

		// If rollMode is already specified, don't override it
		if (!dialogData.rollMode) {
			dialogData.rollMode = game.settings.get("core", "rollMode");
		}

		return foundry.applications.handlebars.renderTemplate(dialogTemplate, dialogData);
	}

	/**
	 * Renders a Roll Dialog and displays the appropriate bonuses
	 * @param {Array<string>} parts - Predetermined roll dice & @bonuses
	 * @param {object} data 				- Data container with dialogTitle
	 * @param {object} options 			- Configuration options for dialog
	 * @returns {Promise(Roll)}			- Returns the promise of evaluated roll(s)
	 */
	static async RollDialog(parts, data, options={}) {
		if ( options.fastForward ) {
			return await this.Roll(parts, data, false, 0, options);
		}

		let rollDialogSD = new RollDialogSD({parts, data, options});
		rollDialogSD.render(true);

		/*if (!options.title) {
			options.title = game.i18n.localize("SHADOWDARK.dialog.roll");
		}

		var advantageTooltip = options.advantageTooltip ?? "";
		if (data.advantage && advantageTooltip === "")    advantageTooltip = game.i18n.localize("SHADOWDARK.dialog.tooltip.talent_advantage");
		if (data.disadvantage && advantageTooltip === "") advantageTooltip = game.i18n.localize("SHADOWDARK.dialog.tooltip.talent_disadvantage");
		let advantageCount = 0;

		if (data.actor?.system?.bonuses?.advantageOnAllAttacks)
		{
			advantageCount++;
			if (advantageTooltip !== "") advantageTooltip += "\n";
			advantageTooltip += game.i18n.localize("SHADOWDARK.dialog.tooltip.advantage_on_all_attacks");
		}

		var newTarget = options.target;
		var tokens = [];
		if (options.targetToken) tokens.push(options.targetToken);
		for (var token of tokens)
		{
			if (token.actor.system?.bonuses?.displacementField)
			{
				advantageCount--;
				if (advantageTooltip !== "") advantageTooltip += "\n";
				advantageTooltip += game.i18n.localize("SHADOWDARK.dialog.tooltip.displacement_disadvantage");
				break;
			}

			if (options.target && token.actor.system.bonuses?.bloodiedAC && token.actor.system.attributes.hp.value <= token.actor.system.attributes.hp.max / 2)
			{
				if (newTarget < options.target + token.actor.system.bonuses.bloodiedAC)
					newTarget = options.target + token.actor.system.bonuses.bloodiedAC;
			}
			if (options.target && token.actor.system.bonuses?.shieldWall)
			{
				newTarget += await this.shieldWallBonus(token.actor);
			}
		}
		options.target = newTarget;

		if (data.item?.isWeapon())
		{
			if(!(await data.actor.isProficient(data.item)))
			{
				advantageCount--;
				if (advantageTooltip !== "") advantageTooltip += "\n";
				advantageTooltip += game.i18n.localize("SHADOWDARK.dialog.tooltip.not_proficient_with_weapon");
			}
		}

		if(!(await data.actor.isProficientWithAllEquippedArmor()))
		{
			advantageCount--;
			if (advantageTooltip !== "") advantageTooltip += "\n";
			advantageTooltip += game.i18n.localize("SHADOWDARK.dialog.tooltip.not_proficient_with_armor");
		}

		if (advantageCount > 0)
		{
			if (data.disadvantage)
			{
				 data.disadvantage = false;
				 advantageCount--;
			}
			if (!data.advantage && advantageCount > 0) data.advantage = true;
		}
		else if (advantageCount < 0)
		{
			if (data.advantage)
			{
				data.advantage = false;
				advantageCount++;
			}
			if (!data.disadvantage && advantageCount < 0) data.disadvantage = true;
		}

		if (data.actor?.system?.bonuses?.targetLock) data.targetLock = true;

		if (data.actor?.system?.bonuses?.packTactics)
		{
			if (!data.talentBonus) data.talentBonus = 0;
			data.talentBonus += this.packTacticsBonus(data.actor);
		}

		if (data.actor?.system?.bonuses?.poisonPenalty)
		{
			if (!data.talentBonus) data.talentBonus = 0;
			data.talentBonus += data.actor?.system?.bonuses?.poisonPenalty;
		}
		
		// Render the HTML for the dialog
		let content = await this._getRollDialogContent(parts, data, options);
		
		const dialogData = {
			window: { title: options.title },
			content,
			classes: ["shadowdark", "shadowdark-dialog", "window-app", 'themed', 'theme-light'],
			buttons: [
				{
					action: "advantage",
					class: ["advantage"],
					label: game.i18n.localize("SHADOWDARK.roll.advantage"),
					callback: (event, button, dialog) => {
						return this.Roll(parts, data, dialog.element, 1, options);
					},
				},
				{
					action: "normal",
					default: true,
					label: game.i18n.localize("SHADOWDARK.roll.normal"),
					callback: (event, button, dialog) => {
						return this.Roll(parts, data, dialog.element, 0, options);
					},
				},
				{
					action: "disadvantage",
					class: ["disadvantage"],
					label: game.i18n.localize("SHADOWDARK.roll.disadvantage"),
					callback: (event, button, dialog) => {
						return this.Roll(parts, data, dialog.element, -1, options);
					},
				},
			],
			close: () => null,
			default: "normal",
			render: event => {
				let html = event.target.element;
				// Check if the actor has advantage, and add highlight if that
				// is the case
				if (data.actor?.hasAdvantage(data)) {
					if (typeof html.find === "function") {
						html.find("button.advantage")
							.attr("title", advantageTooltip)
							.addClass("talent-highlight");
					} else {
						const button = html.querySelector('button[data-action="advantage"]');

						if (button) {
  							button.title = advantageTooltip;
  							button.classList.add("talent-highlight");
						}
					}
				}
				// Check if the actor has disadvantage, and add highlight if that
				// is the case
				if (data.disadvantage) {
					if (typeof html.find === "function") {
						html.find("button.disadvantage")
							.attr("title", advantageTooltip)
							.addClass("talent-highlight");
					} else {
						const button = html.querySelector('button[data-action="disadvantage"]');

						if (button) {
  							button.title = advantageTooltip;
  							button.classList.add("talent-highlight");
						}
					}
				}
			},
		};

		return foundry.applications.api.DialogV2.wait(dialogData, options.dialogOptions);*/
	}

	static packTacticsBonus(actor) {
		for (const scene of game.scenes) {
			var token = scene.tokens.find(t => t.actorId === actor.id);
			if (token)
			{
				//This is the scene.
				var equalTokens = [token];
				equalTokens = UtilitySD.getGroupedTokens(scene, equalTokens);
				return equalTokens.length - 1;
			}
		}
		return 0;
	}

	static shieldWallBonus(actor) {
		let bonus = actor.system.bonuses?.shieldWall ?? 0;
		for (const scene of game.scenes) {
			var token = scene.tokens.find(t => t.actorId === actor.id);
			if (token)
			{
				//This is the scene.
				for (var sceneToken of scene.tokens)
				{
					if (sceneToken === token) continue;
					if (sceneToken._source.name.slugify() === token._source.name.slugify())
					{
						const distance = UtilitySD.distanceBetweenTokens(scene, token, sceneToken);
						if (distance < 1) {
							return bonus;
						}
					}
				}
			}
		}
		return 0;
	}

	/* -------------------------------------------- */
	/*  Chat Card Generation for Displaying         */
	/* -------------------------------------------- */

	/**
	 * Parse roll data and optional target value
	 * @param {object} rollResult 		- Response from `_roll()`
	 * @param {object} speaker  			- ChatMessage.getSpeaker who will be sending the message
	 * @param {number|false} target 	- Target value to beat with the roll
	 * @return {object}								- Data for rendering a chatcard
	 */
	static _getChatCardData(rolls, speaker, hitLocation, target=false) {
		const chatData = {
			user: game.user.id,
			speaker: speaker,
			alias: speaker,
			hitLocation,
			flags: {
				"isRoll": {value: true},
				"rolls": {value: rolls},
				"core.canPopout": {value: true},
				"hasTarget": {value: target !== null && target !== false},
				"critical": {value: rolls?.main?.critical},
			},
		};
		if (target !== null) chatData.flags.success = {value: rolls.main.roll.total >= target};
		return chatData;
	}

	/**
	 * Generate Template Data for displaying custom chat cards
	 * @param {object} data 		- Optional data containing `item` and `actor`
	 * @param {object} options 	- Optional options for configuring chat card,
	 * e.g. `flavor`, `title`
	 * @returns {object}				- Data to populate the Chat Card template
	 */
	static async _getChatCardTemplateData(data, options={}) {
		const templateData = {
			data,
			title: (options.title) ? options.title : game.i18n.localize("SHADOWDARK.chatcard.default"),
			flavor: (options.flavor)
				? options.flavor : (options.title)
					? options.title : game.i18n.localize("SHADOWDARK.chatcard.default"),
			isSpell: false,
			isWeapon: false,
			isMagic: false,
			isFocusRoll: options.isFocusRoll,
			damageRollName: data.rolls.damage2 ? game.i18n.localize("SHADOWDARK.roll.damages") : (data.isHealing ? game.i18n.localize("SHADOWDARK.roll.healing") : game.i18n.localize("SHADOWDARK.roll.damage")),
			isRoll: true,
			isNPC: data.actor?.type === "NPC",
			targetDC: options.target ?? false,
		};

		if (data.rolls.main) {
			templateData._formula = data.rolls.main.roll._formula;
		}
		if (data.item) {
			templateData.isSpell = data.item.isSpell();
			templateData.isWeapon = data.item.isWeapon();

			if (templateData.isWeapon) {
				if (await data.item.isVersatile()) {
					const hand = options.handedness === "1h" ? "one" : "two";

					templateData.damageRollName = game.i18n.localize(
						`SHADOWDARK.roll.${hand}_handed_damage`
					);
				}
			}
			const propertyNames = [];

			for (const property of await data.item.propertyItems()) {
				propertyNames.push(property.name);
			}

			templateData.propertyNames = propertyNames;
		}
		if ((data.auraMagic && data.damage) || (data.abyssalMagic && data.damage) || (data.mistMagic && data.damage) || (data.nanoMagic && data.damage) || (data.rollType?.includes('-magic') && data.damage))
		{
			templateData.isMagicWithDamage = true;
			if (data.rolls.main.critical == "failure")
				templateData.data.showDamage = false;
		}

		return templateData;
	}

	/**
	 * Generate HTML for a chat card for a roll
	 * @param {object} data 		- Optional data containing `item` and `actor`
	 * @param {object} options 	- Optional options for configuring chat card,
	 * e.g. `flavor`, `title`
	 * @returns {jQuery}				- Rendered HTML for chat card
	 */
	static async _getChatCardContent(
		data,
		options = {}
	) {
		const chatCardTemplate = options.chatCardTemplate
			? options.chatCardTemplate
			: "systems/shadowdark/templates/chat/roll-card.hbs";

		const chatCardData = await this._getChatCardTemplateData(data, options);

		return foundry.applications.handlebars.renderTemplate(chatCardTemplate, chatCardData);
	}

	/**
	 * Takes a data object containing rolls and renders them. Also optionally
	 * renders 3D Dice using Dice So Nice integration.
	 * @param {object} data 			- Data from rolling
	 * @param {-1|0|1} adv 				- Advantage indicator
	 * @param {object} options 		- Optional configuration for chat card
	 * @returns {Promise<object>}
	 */
	static async _renderRoll(data, adv=0, options={}) {
		const chatData = await this._getChatCardData(
			data.rolls,
			(options.speaker) ? options.speaker : ChatMessage.getSpeaker(),
			data.hitLocation,
			options.target
		);

		data.rolls.main.success = (chatData.flags.success)
			? chatData.flags.success
			: null;

		options.rollMode = this._translateRollModeFromLabel(options.rollMode);
		if ( options.rollMode === "blindroll" ) data.rolls.main.blind = true;
		if(!data.acMisses) data.acMisses = [];
		data.showDamage = true;
		if (data.acMisses.length && !data.wasAnyoneHit)
			data.showDamage = false;
		if (data.resistanceRolls?.length)
		{
			let showDamage = false;
			for (const resistanceRoll of data.resistanceRolls)
			{
				if (!resistanceRoll.main.success.value)
					showDamage = true;
			}
			data.showDamage = showDamage;
		}

		const content = await this._getChatCardContent(data, options);

		chatData.content = content;

		// Modify the flavor of the chat card
		if (options.flavor) {
			chatData.flavor = options.flavor;

			switch (adv) {
				case 1:
					chatData.flavor = game.i18n.format(
						"SHADOWDARK.roll.advantage_title",
						{ title: options.flavor }
					);
					break;
				case -1:
					chatData.flavor = game.i18n.format(
						"SHADOWDARK.roll.disadvantage_title",
						{ title: options.flavor }
					);
					break;
			}
		}

		// Integration with Dice So Nice
		if (game.dice3d) {
			await this._rollDiceSoNice(data.rolls, chatData, options.chatMessage, options.rollMode);
		}
		else {
			chatData.sound = CONFIG.sounds.dice;
		}

		if (options.chatMessage !== false) {
			ChatMessage.applyRollMode(chatData, options.rollMode);
			ChatMessage.create(chatData);
		}

		return data;
	}

	/* -------------------------------------------- */
	/*  Integrations                                */
	/* -------------------------------------------- */

	wait(ms) {
  		return new Promise(resolve => setTimeout(resolve, ms));
	}

	/**
	 * Renders Dice So Nice in order of D20 -> Damage Rolls and creates
	 * a chat message with the generated content.
	 * @param {object} rolls 					- Object containing evaluated rolls
	 * @param {object} chatData 			- Parsed roll data as generated by _getchatCardData
	 * 																  augmented with content from
	 *                                  _getChatCardTemplateData
	 * @param {boolean} chatMessage 	- Boolean to display chat message or just generate it
	 * @return {object}								- Returns the D20 result
	 */
	static async _rollDiceSoNice(rolls, chatData, chatMessage, rollMode) {
		const rollsToShow = [rolls.main.roll];

		if ( rolls.damage )
			rollsToShow.push(rolls.damage.roll);
		if ( rolls.damage2 )
			rollsToShow.push(rolls.damage2.roll);
		if ( rolls.secondaryDamage )
			rollsToShow.push(rolls.secondaryDamage.roll);
		if (rolls.extraDamage)
			rollsToShow.push(...rolls.extraDamage.map(e => e.roll));

		const { whisper, blind } = this.getRollModeSettings(rollMode);

		// Only await on the final dice roll of the sequence as it looks nicer
		// if all the dice roll before the chat message appears
		//
		const numRolls = rollsToShow.length;
		let currentRoll = 1;
		for (const roll of rollsToShow) {
			if (currentRoll === numRolls) {
				await game.dice3d.showForRoll(roll, game.user, true, whisper, blind);
			}
			else {
				await game.dice3d.showForRoll(roll, game.user, true, whisper, blind);
			}
			currentRoll++;
		}
	}

	static _translateRollModeFromLabel(rollMode) {
		switch (rollMode)
		{
			case "CHAT.RollBlind":
				return "blindroll";
			case "CHAT.RollPrivate":
				return "gmroll";
			case "CHAT.RollPublic":
				return "publicroll";
			case "CHAT.RollSelf":
				return "selfroll";
			default: 
				return 'publicroll';
		}
	}

	static getRollModeSettings(rollMode) {
		//const rollMode = game.settings.get("core", "rollMode");

		let blind = false;
		let whisper = null;

		switch (rollMode) {
			case "CHAT.RollBlind":
			case "blindroll": {
				blind = true;
			}
			case "CHAT.RollPrivate":
			case "gmroll": {
				const gmList = game.users.filter(user => user.isGM);
				const gmIDList = [];
				gmList.forEach(gm => gmIDList.push(gm.id));
				whisper = gmIDList;
				break;
			}
			case "CHAT.RollPublic":
			case "roll": {
				const userList = game.users.filter(user => user.active);
				const userIDList = [];
				userList.forEach(user => userIDList.push(user.id));
				whisper = userIDList;
				break;
			}
			case "CHAT.RollSelf":
			case "selfroll": {
				whisper = [game.user.id];
				break;
			}
			default: {
				break;
			}
		}
		return { whisper, blind };
	}
}
